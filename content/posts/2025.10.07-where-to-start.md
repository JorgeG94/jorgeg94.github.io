+++
title = "Getting started with Programming, part 3: where to start"
date = "2025-10-07T22:01:00"
author = "Jorge"
#cover = "img/hello.jpg"
description = "How to get started with programming for science, part 3."
+++

## Intro

If you've gotten to this point of the post series, you are truly curious. If you started here, 
feel free to go back (or not!). 

Most of us who started writing code for scientific applications are probably students at any 
level of studies: ranging from high school to any level of academic - maybe you are also in an
industrial setting and you need to help your company write some code. The fun thing is that, at 
any point, anyone can be tasked with writing code. 

## Where are you and where are you going?

The first question I have to ask you (you have to ask yourself) is: *am I supposed to write a new 
program from scratch or am I hooking up to an existing code?* 

This is an important question because it dictates how much _design_ you need to do. If you are working
with an existing codebase you will probably end up writing a new set of routines and functions within 
the program that reuse the existing architecture of it. For example, in the realm of quantum chemistry 
you might be tasked with adding a new property calculation; in weather maybe a new parametrization; in 
finite element methods a new discretization, etc. 

This means that the code you will be working with already has a _design_ in place, it will use classes 
and object orientation; functional programming; etc. you simply have to look at how the code is structured
and structure your program similarly. 

*This is not always the case*

In academic software there is often little design in place. The architecture is dictated by the student who
wrote the most code and their design decision are based on "paper driven design", i.e. almost everything is 
secondary, I just want to write a paper and graduate/move on. 

This is also not always the case. Some academic programs have very strong foundations and they have a style guide
and examples that they enforce for new code. Pray that the code you're working with looks like this one, since
this will make your life easier. 

So, *what if it is like the former?* Well, then comes the fun/annoying part of writing code: designing your program.  


## On program design 

Let's think about the city of Villahermosa, Tabasco in my native Mexico. It is built on a swamp...so it floods often. The
design decision of building it on a floodplain was, in retrospective, not great. 

Mexico City is built on top of the ruins of Tenochtitlan, which was built on reclaimed land on the lake of Texcoco. Naturally, 
some parts of the city are sinking. Expanding the metropolitan area by continuously reclaiming area on the lake is probably
not the best idea on the planet. Now Mexico City has around 25 million people, it is a bit too late and to complex to 
rearchitecture the idea. 

Think about software design similarly to building a city or a house. If you've played games like Cities Skylines or Factorio 
you know that choosing the design of your city/factory is important. Otherwise, you will be quickly burdened by bottlenecks 
that will constrict the rate at which you can grow your project. Software design is extremely similar. A bad design can lead 
to a new feature taking a month versus a couple of days to implement. 

So, if you are working in a program that has little to no design it is your duty to start building said infrastructure. Why? 
Because that's what good programmers do. Also, it will pay off, believe me. 

## How do I start, then? 

The first step is to assess what is the status of the current program you are working with. This by no means is saying that 
most code is bad - you should not arrive at a new group and seek to impose your ideas without demonstrating that you are 
sane/correct to do so. So let's look at some _objective_ measures to help you reason about a the state of a code. 

WIP: next up, definition of unit tests, regression tests, testing automation, CI/CD, etc. 






