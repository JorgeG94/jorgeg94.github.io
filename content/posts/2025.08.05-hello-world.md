+++
title = "Getting started with Programming, part 2"
date = "2025-08-05T22:01:00"
author = "Jorge"
#cover = "img/hello.jpg"
description = "How to get started with programming for science, part 2."
+++

## Intro

This is by no means a comprehensive description of programming languages. It is a brief gloss over them 
so that you, the new programmer, has a good idea of what is out there and what are the common _buzz words_
you have to be familiar with.

## On programming languages 

There are many programming languages in the world, choosing the right tool for 
the job is important. There are a couple of concepts we should touch so that you
are familiar with how programming languages difer from each other. 

The "basic" distinction are those that are *compiled* or those that are *interpreted*. Compiled code
is read from the text source form and _compiled_ into machine code before any execution takes place. 

The *compiler* is the tool that does this conversion. Compilers analyze the code and perform many
optimizations that make the resulting executable usually quite fast. For example, C/C++ and Fortran. 

_Interpreted_ codes are executed line by line by an *interpreter* at runtime. For example, Python. 

Generally, compiled codes are faster than interpreted codes (if written correctly). 

A further difference is if a code is *strongly* or *weakly* typed. This mostly reflects on the safety 
of type mixing. For example, in a weakly typed language the expression `"2" + 3` (mixing a character, and an integer)
would result in `23`. Whereas in a strongly typed language, this would result in an error. 

_Type checking_ is closely related to the previous concept. Type checking means when does the program check if 
two types are compatible. In compiled languages, this happens at compile time - this is called _static typing_. 
In interpreted languages, this is done at runtime and this is called _dynamically typed_. 

### A note on memory management 

As you know, your computer has memory (think about RAM); when programs are run they need to use that memory 
and depending on the language the way your code uses memory can be quite different. Languages like C/C++ and 
Fortran use _manual memory management_; this means that the programmer is in charge of allocating and deallocating 
memory for the program to use. Languages like this can have _or not have_ something called a "garbage collector". 

A garbage collector is a program that runs alongisde your code that handles how memory is allocated, used, freed, etc; it 
ensures that no _memory leaks_ happen, which is when memory that is allocated is not freed after it is done being 
used. This can lead to catastrophic failures and runtime errors. 

## Programming paradigms 

A programming paradigm is essentially "How are you going to solve the problem?" You can summarize them into:

- procedural 
- object oriented 
- functional 

A procedural program contains functions, subroutines, and subprograms that are as similar to a recipe as there is. It
basically turns into a step-by-step set of instructions on how to solve the problem. Thinks "how am I executing this?"

An object oriented program uses "objects", which you can think of a "thing" that does something that applies to this thing. Objects offer "encapsulation" which means that you can put things that semantically or programatically belong together, together. 

Functional programming is quite different to all other methodologies. Think like functions in mathematics, you have 
`f(x) = x^2` and once you provide the value of `x` the program evaluates it and returns it. The idea is that each 
function has no side effects in the overall state of the program and thus you can prevent many possible problems. 

Each one of these has its advantages and disadvantages. It is worth noting that most scientific software is written 
in a mixture of procedural and object oriented programming. I have personally not explored functional programming 
much, since I don't think it loans itself to the fields of science I use. However, I encourage you to explore it 
if you find it interesting. Maybe later I can revist this concept. 



